"use client";


import { i as __toESM, t as require_react } from "./react-CQaMAW-R.js";

//#region node_modules/react-intersection-observer/dist/index.mjs
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
	enumerable: true,
	configurable: true,
	writable: true,
	value
}) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var observerMap = /* @__PURE__ */ new Map();
var RootIds = /* @__PURE__ */ new WeakMap();
var rootId = 0;
var unsupportedValue;
function defaultFallbackInView(inView) {
	unsupportedValue = inView;
}
function getRootId(root) {
	if (!root) return "0";
	if (RootIds.has(root)) return RootIds.get(root);
	rootId += 1;
	RootIds.set(root, rootId.toString());
	return RootIds.get(root);
}
function optionsToId(options) {
	return Object.keys(options).sort().filter((key) => options[key] !== void 0).map((key) => {
		return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
	}).toString();
}
function createObserver(options) {
	const id = optionsToId(options);
	let instance = observerMap.get(id);
	if (!instance) {
		const elements = /* @__PURE__ */ new Map();
		let thresholds;
		const observer = new IntersectionObserver((entries) => {
			entries.forEach((entry) => {
				var _a2;
				const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
				if (options.trackVisibility && typeof entry.isVisible === "undefined") entry.isVisible = inView;
				(_a2 = elements.get(entry.target)) == null || _a2.forEach((callback) => {
					callback(inView, entry);
				});
			});
		}, options);
		thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
		instance = {
			id,
			observer,
			elements
		};
		observerMap.set(id, instance);
	}
	return instance;
}
function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
	if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
		const bounds = element.getBoundingClientRect();
		callback(fallbackInView, {
			isIntersecting: fallbackInView,
			target: element,
			intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
			time: 0,
			boundingClientRect: bounds,
			intersectionRect: bounds,
			rootBounds: bounds
		});
		return () => {};
	}
	const { id, observer, elements } = createObserver(options);
	const callbacks = elements.get(element) || [];
	if (!elements.has(element)) elements.set(element, callbacks);
	callbacks.push(callback);
	observer.observe(element);
	return function unobserve() {
		callbacks.splice(callbacks.indexOf(callback), 1);
		if (callbacks.length === 0) {
			elements.delete(element);
			observer.unobserve(element);
		}
		if (elements.size === 0) {
			observer.disconnect();
			observerMap.delete(id);
		}
	};
}
function isPlainChildren(props) {
	return typeof props.children !== "function";
}
var InView = class extends import_react.Component {
	constructor(props) {
		super(props);
		__publicField(this, "node", null);
		__publicField(this, "_unobserveCb", null);
		__publicField(this, "lastInView");
		__publicField(this, "handleNode", (node) => {
			if (this.node) {
				this.unobserve();
				if (!node && !this.props.triggerOnce && !this.props.skip) {
					this.setState({
						inView: !!this.props.initialInView,
						entry: void 0
					});
					this.lastInView = this.props.initialInView;
				}
			}
			this.node = node ? node : null;
			this.observeNode();
		});
		__publicField(this, "handleChange", (inView, entry) => {
			const previousInView = this.lastInView;
			this.lastInView = inView;
			if (previousInView === void 0 && !inView) return;
			if (inView && this.props.triggerOnce) this.unobserve();
			if (!isPlainChildren(this.props)) this.setState({
				inView,
				entry
			});
			if (this.props.onChange) this.props.onChange(inView, entry);
		});
		this.state = {
			inView: !!props.initialInView,
			entry: void 0
		};
		this.lastInView = props.initialInView;
	}
	componentDidMount() {
		this.unobserve();
		this.observeNode();
	}
	componentDidUpdate(prevProps) {
		if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {
			this.unobserve();
			this.observeNode();
		}
	}
	componentWillUnmount() {
		this.unobserve();
	}
	observeNode() {
		if (!this.node || this.props.skip) return;
		const { threshold, root, rootMargin, trackVisibility, delay, fallbackInView } = this.props;
		if (this.lastInView === void 0) this.lastInView = this.props.initialInView;
		this._unobserveCb = observe(this.node, this.handleChange, {
			threshold,
			root,
			rootMargin,
			trackVisibility,
			delay
		}, fallbackInView);
	}
	unobserve() {
		if (this._unobserveCb) {
			this._unobserveCb();
			this._unobserveCb = null;
		}
	}
	render() {
		const { children } = this.props;
		if (typeof children === "function") {
			const { inView, entry } = this.state;
			return children({
				inView,
				entry,
				ref: this.handleNode
			});
		}
		const { as, triggerOnce, threshold, root, rootMargin, onChange, skip, trackVisibility, delay, initialInView, fallbackInView,...props } = this.props;
		return import_react.createElement(as || "div", {
			ref: this.handleNode,
			...props
		}, children);
	}
};
function useInView({ threshold, delay, trackVisibility, rootMargin, root, triggerOnce, skip, initialInView, fallbackInView, onChange } = {}) {
	var _a2;
	const [ref, setRef] = import_react.useState(null);
	const callback = import_react.useRef(onChange);
	const lastInViewRef = import_react.useRef(initialInView);
	const [state, setState] = import_react.useState({
		inView: !!initialInView,
		entry: void 0
	});
	callback.current = onChange;
	import_react.useEffect(() => {
		if (lastInViewRef.current === void 0) lastInViewRef.current = initialInView;
		if (skip || !ref) return;
		let unobserve;
		unobserve = observe(ref, (inView, entry) => {
			const previousInView = lastInViewRef.current;
			lastInViewRef.current = inView;
			if (previousInView === void 0 && !inView) return;
			setState({
				inView,
				entry
			});
			if (callback.current) callback.current(inView, entry);
			if (entry.isIntersecting && triggerOnce && unobserve) {
				unobserve();
				unobserve = void 0;
			}
		}, {
			root,
			rootMargin,
			threshold,
			trackVisibility,
			delay
		}, fallbackInView);
		return () => {
			if (unobserve) unobserve();
		};
	}, [
		Array.isArray(threshold) ? threshold.toString() : threshold,
		ref,
		root,
		rootMargin,
		triggerOnce,
		skip,
		trackVisibility,
		fallbackInView,
		delay
	]);
	const entryTarget = (_a2 = state.entry) == null ? void 0 : _a2.target;
	const previousEntryTarget = import_react.useRef(void 0);
	if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {
		previousEntryTarget.current = entryTarget;
		setState({
			inView: !!initialInView,
			entry: void 0
		});
		lastInViewRef.current = initialInView;
	}
	const result = [
		setRef,
		state.inView,
		state.entry
	];
	result.ref = result[0];
	result.inView = result[1];
	result.entry = result[2];
	return result;
}
var _a, _b;
var useSyncEffect = (_b = (_a = import_react.useInsertionEffect) != null ? _a : import_react.useLayoutEffect) != null ? _b : import_react.useEffect;
var useOnInView = (onIntersectionChange, { threshold, root, rootMargin, trackVisibility, delay, triggerOnce, skip } = {}) => {
	const onIntersectionChangeRef = import_react.useRef(onIntersectionChange);
	const observedElementRef = import_react.useRef(null);
	const observerCleanupRef = import_react.useRef(void 0);
	const lastInViewRef = import_react.useRef(void 0);
	useSyncEffect(() => {
		onIntersectionChangeRef.current = onIntersectionChange;
	}, [onIntersectionChange]);
	return import_react.useCallback((element) => {
		const cleanupExisting = () => {
			if (observerCleanupRef.current) {
				const cleanup = observerCleanupRef.current;
				observerCleanupRef.current = void 0;
				cleanup();
			}
		};
		if (element === observedElementRef.current) return observerCleanupRef.current;
		if (!element || skip) {
			cleanupExisting();
			observedElementRef.current = null;
			lastInViewRef.current = void 0;
			return;
		}
		cleanupExisting();
		observedElementRef.current = element;
		let destroyed = false;
		const destroyObserver = observe(element, (inView, entry) => {
			const previousInView = lastInViewRef.current;
			lastInViewRef.current = inView;
			if (previousInView === void 0 && !inView) return;
			onIntersectionChangeRef.current(inView, entry);
			if (triggerOnce && inView) stopObserving();
		}, {
			threshold,
			root,
			rootMargin,
			trackVisibility,
			delay
		});
		function stopObserving() {
			if (destroyed) return;
			destroyed = true;
			destroyObserver();
			observedElementRef.current = null;
			observerCleanupRef.current = void 0;
			lastInViewRef.current = void 0;
		}
		observerCleanupRef.current = stopObserving;
		return observerCleanupRef.current;
	}, [
		Array.isArray(threshold) ? threshold.toString() : threshold,
		root,
		rootMargin,
		trackVisibility,
		delay,
		triggerOnce,
		skip
	]);
};

//#endregion
export { InView, defaultFallbackInView, observe, useInView, useOnInView };
//# sourceMappingURL=react-intersection-observer.js.map